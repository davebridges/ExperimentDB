

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>io &mdash; ExperimentDB v0.2.dev documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.2.dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="ExperimentDB v0.2.dev documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">ExperimentDB v0.2.dev documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for io</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The io module provides the Python interfaces to stream handling. The</span>
<span class="sd">builtin open function is defined in this module.</span>

<span class="sd">At the top of the I/O hierarchy is the abstract base class IOBase. It</span>
<span class="sd">defines the basic interface to a stream. Note, however, that there is no</span>
<span class="sd">separation between reading and writing to streams; implementations are</span>
<span class="sd">allowed to throw an IOError if they do not support a given operation.</span>

<span class="sd">Extending IOBase is RawIOBase which deals simply with the reading and</span>
<span class="sd">writing of raw bytes to a stream. FileIO subclasses RawIOBase to provide</span>
<span class="sd">an interface to OS files.</span>

<span class="sd">BufferedIOBase deals with buffering on a raw byte stream (RawIOBase). Its</span>
<span class="sd">subclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer</span>
<span class="sd">streams that are readable, writable, and both respectively.</span>
<span class="sd">BufferedRandom provides a buffered interface to random access</span>
<span class="sd">streams. BytesIO is a simple stream of in-memory bytes.</span>

<span class="sd">Another IOBase subclass, TextIOBase, deals with the encoding and decoding</span>
<span class="sd">of streams into text. TextIOWrapper, which extends it, is a buffered text</span>
<span class="sd">interface to a buffered raw stream (`BufferedIOBase`). Finally, StringIO</span>
<span class="sd">is a in-memory stream for text.</span>

<span class="sd">Argument names are not part of the specification, and only the arguments</span>
<span class="sd">of open() are intended to be used as keyword arguments.</span>

<span class="sd">data:</span>

<span class="sd">DEFAULT_BUFFER_SIZE</span>

<span class="sd">   An int containing the default buffer size used by the module&#39;s buffered</span>
<span class="sd">   I/O classes. open() uses the file&#39;s blksize (as obtained by os.stat) if</span>
<span class="sd">   possible.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c"># New I/O library conforming to PEP 3116.</span>

<span class="c"># This is a prototype; hopefully eventually some of this will be</span>
<span class="c"># reimplemented in C.</span>

<span class="c"># XXX edge cases when switching between reading/writing</span>
<span class="c"># XXX need to support 1 meaning line-buffered</span>
<span class="c"># XXX whenever an argument is None, use the default value</span>
<span class="c"># XXX read/write ops should check readable/writable</span>
<span class="c"># XXX buffered readinto should work with arbitrary buffer objects</span>
<span class="c"># XXX use incremental encoder for text output, at least for UTF-16 and UTF-8-SIG</span>
<span class="c"># XXX check writable, readable and seekable in appropriate places</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">unicode_literals</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;Guido van Rossum &lt;guido@python.org&gt;, &quot;</span>
              <span class="s">&quot;Mike Verdone &lt;mike.verdone@gmail.com&gt;, &quot;</span>
              <span class="s">&quot;Mark Russell &lt;mark.russell@zen.co.uk&gt;&quot;</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;BlockingIOError&quot;</span><span class="p">,</span> <span class="s">&quot;open&quot;</span><span class="p">,</span> <span class="s">&quot;IOBase&quot;</span><span class="p">,</span> <span class="s">&quot;RawIOBase&quot;</span><span class="p">,</span> <span class="s">&quot;FileIO&quot;</span><span class="p">,</span>
           <span class="s">&quot;BytesIO&quot;</span><span class="p">,</span> <span class="s">&quot;StringIO&quot;</span><span class="p">,</span> <span class="s">&quot;BufferedIOBase&quot;</span><span class="p">,</span>
           <span class="s">&quot;BufferedReader&quot;</span><span class="p">,</span> <span class="s">&quot;BufferedWriter&quot;</span><span class="p">,</span> <span class="s">&quot;BufferedRWPair&quot;</span><span class="p">,</span>
           <span class="s">&quot;BufferedRandom&quot;</span><span class="p">,</span> <span class="s">&quot;TextIOBase&quot;</span><span class="p">,</span> <span class="s">&quot;TextIOWrapper&quot;</span><span class="p">]</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">codecs</span>
<span class="kn">import</span> <span class="nn">_fileio</span>
<span class="kn">import</span> <span class="nn">threading</span>

<span class="c"># open() uses st_blksize whenever we can</span>
<span class="n">DEFAULT_BUFFER_SIZE</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">1024</span>  <span class="c"># bytes</span>

<span class="c"># py3k has only new style classes</span>
<span class="n">__metaclass__</span> <span class="o">=</span> <span class="nb">type</span>

<div class="viewcode-block" id="BlockingIOError"><a class="viewcode-back" href="../api.html#io.BlockingIOError">[docs]</a><span class="k">class</span> <span class="nc">BlockingIOError</span><span class="p">(</span><span class="ne">IOError</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Exception raised when I/O would block on a non-blocking I/O stream.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span> <span class="n">strerror</span><span class="p">,</span> <span class="n">characters_written</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="ne">IOError</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span> <span class="n">strerror</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">characters_written</span> <span class="o">=</span> <span class="n">characters_written</span>

</div>
<div class="viewcode-block" id="open"><a class="viewcode-back" href="../api.html#io.open">[docs]</a><span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&quot;r&quot;</span><span class="p">,</span> <span class="n">buffering</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
         <span class="n">newline</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">closefd</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="s">r&quot;&quot;&quot;Open file and return a stream. If the file cannot be opened, an IOError is</span>
<span class="s">    raised.</span>

<span class="s">    file is either a string giving the name (and the path if the file</span>
<span class="s">    isn&#39;t in the current working directory) of the file to be opened or an</span>
<span class="s">    integer file descriptor of the file to be wrapped. (If a file</span>
<span class="s">    descriptor is given, it is closed when the returned I/O object is</span>
<span class="s">    closed, unless closefd is set to False.)</span>

<span class="s">    mode is an optional string that specifies the mode in which the file</span>
<span class="s">    is opened. It defaults to &#39;r&#39; which means open for reading in text</span>
<span class="s">    mode.  Other common values are &#39;w&#39; for writing (truncating the file if</span>
<span class="s">    it already exists), and &#39;a&#39; for appending (which on some Unix systems,</span>
<span class="s">    means that all writes append to the end of the file regardless of the</span>
<span class="s">    current seek position). In text mode, if encoding is not specified the</span>
<span class="s">    encoding used is platform dependent. (For reading and writing raw</span>
<span class="s">    bytes use binary mode and leave encoding unspecified.) The available</span>
<span class="s">    modes are:</span>

<span class="s">    ========= ===============================================================</span>
<span class="s">    Character Meaning</span>
<span class="s">    --------- ---------------------------------------------------------------</span>
<span class="s">    &#39;r&#39;       open for reading (default)</span>
<span class="s">    &#39;w&#39;       open for writing, truncating the file first</span>
<span class="s">    &#39;a&#39;       open for writing, appending to the end of the file if it exists</span>
<span class="s">    &#39;b&#39;       binary mode</span>
<span class="s">    &#39;t&#39;       text mode (default)</span>
<span class="s">    &#39;+&#39;       open a disk file for updating (reading and writing)</span>
<span class="s">    &#39;U&#39;       universal newline mode (for backwards compatibility; unneeded</span>
<span class="s">              for new code)</span>
<span class="s">    ========= ===============================================================</span>

<span class="s">    The default mode is &#39;rt&#39; (open for reading text). For binary random</span>
<span class="s">    access, the mode &#39;w+b&#39; opens and truncates the file to 0 bytes, while</span>
<span class="s">    &#39;r+b&#39; opens the file without truncation.</span>

<span class="s">    Python distinguishes between files opened in binary and text modes,</span>
<span class="s">    even when the underlying operating system doesn&#39;t. Files opened in</span>
<span class="s">    binary mode (appending &#39;b&#39; to the mode argument) return contents as</span>
<span class="s">    bytes objects without any decoding. In text mode (the default, or when</span>
<span class="s">    &#39;t&#39; is appended to the mode argument), the contents of the file are</span>
<span class="s">    returned as strings, the bytes having been first decoded using a</span>
<span class="s">    platform-dependent encoding or using the specified encoding if given.</span>

<span class="s">    buffering is an optional integer used to set the buffering policy.</span>
<span class="s">    Pass 0 to switch buffering off (only allowed in binary mode), 1 to select</span>
<span class="s">    line buffering (only usable in text mode), and an integer &gt; 1 to indicate</span>
<span class="s">    the size of a fixed-size chunk buffer.  When no buffering argument is</span>
<span class="s">    given, the default buffering policy works as follows:</span>

<span class="s">    * Binary files are buffered in fixed-size chunks; the size of the buffer</span>
<span class="s">      is chosen using a heuristic trying to determine the underlying device&#39;s</span>
<span class="s">      &quot;block size&quot; and falling back on `io.DEFAULT_BUFFER_SIZE`.</span>
<span class="s">      On many systems, the buffer will typically be 4096 or 8192 bytes long.</span>

<span class="s">    * &quot;Interactive&quot; text files (files for which isatty() returns True)</span>
<span class="s">      use line buffering.  Other text files use the policy described above</span>
<span class="s">      for binary files.</span>

<span class="s">    encoding is the name of the encoding used to decode or encode the</span>
<span class="s">    file. This should only be used in text mode. The default encoding is</span>
<span class="s">    platform dependent, but any encoding supported by Python can be</span>
<span class="s">    passed.  See the codecs module for the list of supported encodings.</span>

<span class="s">    errors is an optional string that specifies how encoding errors are to</span>
<span class="s">    be handled---this argument should not be used in binary mode. Pass</span>
<span class="s">    &#39;strict&#39; to raise a ValueError exception if there is an encoding error</span>
<span class="s">    (the default of None has the same effect), or pass &#39;ignore&#39; to ignore</span>
<span class="s">    errors. (Note that ignoring encoding errors can lead to data loss.)</span>
<span class="s">    See the documentation for codecs.register for a list of the permitted</span>
<span class="s">    encoding error strings.</span>

<span class="s">    newline controls how universal newlines works (it only applies to text</span>
<span class="s">    mode). It can be None, &#39;&#39;, &#39;\n&#39;, &#39;\r&#39;, and &#39;\r\n&#39;.  It works as</span>
<span class="s">    follows:</span>

<span class="s">    * On input, if newline is None, universal newlines mode is</span>
<span class="s">      enabled. Lines in the input can end in &#39;\n&#39;, &#39;\r&#39;, or &#39;\r\n&#39;, and</span>
<span class="s">      these are translated into &#39;\n&#39; before being returned to the</span>
<span class="s">      caller. If it is &#39;&#39;, universal newline mode is enabled, but line</span>
<span class="s">      endings are returned to the caller untranslated. If it has any of</span>
<span class="s">      the other legal values, input lines are only terminated by the given</span>
<span class="s">      string, and the line ending is returned to the caller untranslated.</span>

<span class="s">    * On output, if newline is None, any &#39;\n&#39; characters written are</span>
<span class="s">      translated to the system default line separator, os.linesep. If</span>
<span class="s">      newline is &#39;&#39;, no translation takes place. If newline is any of the</span>
<span class="s">      other legal values, any &#39;\n&#39; characters written are translated to</span>
<span class="s">      the given string.</span>

<span class="s">    If closefd is False, the underlying file descriptor will be kept open</span>
<span class="s">    when the file is closed. This does not work when a file name is given</span>
<span class="s">    and must be True in that case.</span>

<span class="s">    open() returns a file object whose type depends on the mode, and</span>
<span class="s">    through which the standard file operations such as reading and writing</span>
<span class="s">    are performed. When open() is used to open a file in a text mode (&#39;w&#39;,</span>
<span class="s">    &#39;r&#39;, &#39;wt&#39;, &#39;rt&#39;, etc.), it returns a TextIOWrapper. When used to open</span>
<span class="s">    a file in a binary mode, the returned class varies: in read binary</span>
<span class="s">    mode, it returns a BufferedReader; in write binary and append binary</span>
<span class="s">    modes, it returns a BufferedWriter, and in read/write mode, it returns</span>
<span class="s">    a BufferedRandom.</span>

<span class="s">    It is also possible to use a string or bytearray as a file for both</span>
<span class="s">    reading and writing. For strings StringIO can be used like a file</span>
<span class="s">    opened in a text mode, and for bytes a BytesIO can be used like a file</span>
<span class="s">    opened in a binary mode.</span>
<span class="s">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="p">(</span><span class="nb">basestring</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;invalid file: </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">file</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;invalid mode: </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">mode</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">buffering</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">buffering</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;invalid buffering: </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">buffering</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">encoding</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;invalid encoding: </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">encoding</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">errors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">errors</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;invalid errors: </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">errors</span><span class="p">)</span>
    <span class="n">modes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">modes</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="s">&quot;arwb+tU&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">modes</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;invalid mode: </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">mode</span><span class="p">)</span>
    <span class="n">reading</span> <span class="o">=</span> <span class="s">&quot;r&quot;</span> <span class="ow">in</span> <span class="n">modes</span>
    <span class="n">writing</span> <span class="o">=</span> <span class="s">&quot;w&quot;</span> <span class="ow">in</span> <span class="n">modes</span>
    <span class="n">appending</span> <span class="o">=</span> <span class="s">&quot;a&quot;</span> <span class="ow">in</span> <span class="n">modes</span>
    <span class="n">updating</span> <span class="o">=</span> <span class="s">&quot;+&quot;</span> <span class="ow">in</span> <span class="n">modes</span>
    <span class="n">text</span> <span class="o">=</span> <span class="s">&quot;t&quot;</span> <span class="ow">in</span> <span class="n">modes</span>
    <span class="n">binary</span> <span class="o">=</span> <span class="s">&quot;b&quot;</span> <span class="ow">in</span> <span class="n">modes</span>
    <span class="k">if</span> <span class="s">&quot;U&quot;</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">writing</span> <span class="ow">or</span> <span class="n">appending</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;can&#39;t use U and writing mode at once&quot;</span><span class="p">)</span>
        <span class="n">reading</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">if</span> <span class="n">text</span> <span class="ow">and</span> <span class="n">binary</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;can&#39;t have text and binary mode at once&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">reading</span> <span class="o">+</span> <span class="n">writing</span> <span class="o">+</span> <span class="n">appending</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;can&#39;t have read/write/append mode at once&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">reading</span> <span class="ow">or</span> <span class="n">writing</span> <span class="ow">or</span> <span class="n">appending</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;must have exactly one of read/write/append mode&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">binary</span> <span class="ow">and</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;binary mode doesn&#39;t take an encoding argument&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">binary</span> <span class="ow">and</span> <span class="n">errors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;binary mode doesn&#39;t take an errors argument&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">binary</span> <span class="ow">and</span> <span class="n">newline</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;binary mode doesn&#39;t take a newline argument&quot;</span><span class="p">)</span>
    <span class="n">raw</span> <span class="o">=</span> <span class="n">FileIO</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span>
                 <span class="p">(</span><span class="n">reading</span> <span class="ow">and</span> <span class="s">&quot;r&quot;</span> <span class="ow">or</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span>
                 <span class="p">(</span><span class="n">writing</span> <span class="ow">and</span> <span class="s">&quot;w&quot;</span> <span class="ow">or</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span>
                 <span class="p">(</span><span class="n">appending</span> <span class="ow">and</span> <span class="s">&quot;a&quot;</span> <span class="ow">or</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span>
                 <span class="p">(</span><span class="n">updating</span> <span class="ow">and</span> <span class="s">&quot;+&quot;</span> <span class="ow">or</span> <span class="s">&quot;&quot;</span><span class="p">),</span>
                 <span class="n">closefd</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">buffering</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">buffering</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">line_buffering</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="n">buffering</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">buffering</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">raw</span><span class="o">.</span><span class="n">isatty</span><span class="p">():</span>
        <span class="n">buffering</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">line_buffering</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">if</span> <span class="n">buffering</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">buffering</span> <span class="o">=</span> <span class="n">DEFAULT_BUFFER_SIZE</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">bs</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">fstat</span><span class="p">(</span><span class="n">raw</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span><span class="o">.</span><span class="n">st_blksize</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">buffering</span> <span class="o">=</span> <span class="n">bs</span>
    <span class="k">if</span> <span class="n">buffering</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;invalid buffering size&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">buffering</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">binary</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">raw</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;can&#39;t have unbuffered text I/O&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">updating</span><span class="p">:</span>
        <span class="nb">buffer</span> <span class="o">=</span> <span class="n">BufferedRandom</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="n">buffering</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">writing</span> <span class="ow">or</span> <span class="n">appending</span><span class="p">:</span>
        <span class="nb">buffer</span> <span class="o">=</span> <span class="n">BufferedWriter</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="n">buffering</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">reading</span><span class="p">:</span>
        <span class="nb">buffer</span> <span class="o">=</span> <span class="n">BufferedReader</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="n">buffering</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;unknown mode: </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">mode</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">binary</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">buffer</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">TextIOWrapper</span><span class="p">(</span><span class="nb">buffer</span><span class="p">,</span> <span class="n">encoding</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">newline</span><span class="p">,</span> <span class="n">line_buffering</span><span class="p">)</span>
    <span class="n">text</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>
    <span class="k">return</span> <span class="n">text</span>
</div>
<span class="k">class</span> <span class="nc">_DocDescriptor</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Helper for builtins.open.__doc__</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">typ</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s">&quot;open(file, mode=&#39;r&#39;, buffering=None, encoding=None, &quot;</span>
                 <span class="s">&quot;errors=None, newline=None, closefd=True)</span><span class="se">\n\n</span><span class="s">&quot;</span> <span class="o">+</span>
            <span class="nb">open</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">OpenWrapper</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Wrapper for builtins.open</span>

<span class="sd">    Trick so that open won&#39;t become a bound method when stored</span>
<span class="sd">    as a class variable (as dumbdbm does).</span>

<span class="sd">    See initstdio() in Python/pythonrun.c.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__doc__</span> <span class="o">=</span> <span class="n">_DocDescriptor</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">open</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">UnsupportedOperation</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">):</span>
    <span class="k">pass</span>


<div class="viewcode-block" id="IOBase"><a class="viewcode-back" href="../api.html#io.IOBase">[docs]</a><span class="k">class</span> <span class="nc">IOBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;The abstract base class for all I/O classes, acting on streams of</span>
<span class="sd">    bytes. There is no public constructor.</span>

<span class="sd">    This class provides dummy implementations for many methods that</span>
<span class="sd">    derived classes can override selectively; the default implementations</span>
<span class="sd">    represent a file that cannot be read, written or seeked.</span>

<span class="sd">    Even though IOBase does not declare read, readinto, or write because</span>
<span class="sd">    their signatures will vary, implementations and clients should</span>
<span class="sd">    consider those methods part of the interface. Also, implementations</span>
<span class="sd">    may raise a IOError when operations they do not support are called.</span>

<span class="sd">    The basic type used for binary data read from or written to a file is</span>
<span class="sd">    bytes. bytearrays are accepted too, and in some cases (such as</span>
<span class="sd">    readinto) needed. Text I/O classes work with str data.</span>

<span class="sd">    Note that calling any method (even inquiries) on a closed stream is</span>
<span class="sd">    undefined. Implementations may raise IOError in this case.</span>

<span class="sd">    IOBase (and its subclasses) support the iterator protocol, meaning</span>
<span class="sd">    that an IOBase object can be iterated over yielding the lines in a</span>
<span class="sd">    stream.</span>

<span class="sd">    IOBase also supports the :keyword:`with` statement. In this example,</span>
<span class="sd">    fp is closed after the suite of the with statment is complete:</span>

<span class="sd">    with open(&#39;spam.txt&#39;, &#39;r&#39;) as fp:</span>
<span class="sd">        fp.write(&#39;Spam and eggs!&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">abc</span><span class="o">.</span><span class="n">ABCMeta</span>

    <span class="c">### Internal ###</span>

    <span class="k">def</span> <span class="nf">_unsupported</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Internal: raise an exception for unsupported operations.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">UnsupportedOperation</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">.</span><span class="si">%s</span><span class="s">() not supported&quot;</span> <span class="o">%</span>
                                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

    <span class="c">### Positioning ###</span>

<div class="viewcode-block" id="IOBase.seek"><a class="viewcode-back" href="../api.html#io.IOBase.seek">[docs]</a>    <span class="k">def</span> <span class="nf">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">whence</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Change stream position.</span>

<span class="sd">        Change the stream position to byte offset offset. offset is</span>
<span class="sd">        interpreted relative to the position indicated by whence.  Values</span>
<span class="sd">        for whence are:</span>

<span class="sd">        * 0 -- start of stream (the default); offset should be zero or positive</span>
<span class="sd">        * 1 -- current stream position; offset may be negative</span>
<span class="sd">        * 2 -- end of stream; offset is usually negative</span>

<span class="sd">        Return the new absolute position.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsupported</span><span class="p">(</span><span class="s">&quot;seek&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="IOBase.tell"><a class="viewcode-back" href="../api.html#io.IOBase.tell">[docs]</a>    <span class="k">def</span> <span class="nf">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return current stream position.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="IOBase.truncate"><a class="viewcode-back" href="../api.html#io.IOBase.truncate">[docs]</a>    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Truncate file to size bytes.</span>

<span class="sd">        Size defaults to the current IO position as reported by tell().  Return</span>
<span class="sd">        the new size.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsupported</span><span class="p">(</span><span class="s">&quot;truncate&quot;</span><span class="p">)</span>

    <span class="c">### Flush and close ###</span>
</div>
<div class="viewcode-block" id="IOBase.flush"><a class="viewcode-back" href="../api.html#io.IOBase.flush">[docs]</a>    <span class="k">def</span> <span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Flush write buffers, if applicable.</span>

<span class="sd">        This is not implemented for read-only and non-blocking streams.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># XXX Should this return the number of bytes written???</span>
</div>
    <span class="n">__closed</span> <span class="o">=</span> <span class="bp">False</span>

<div class="viewcode-block" id="IOBase.close"><a class="viewcode-back" href="../api.html#io.IOBase.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Flush and close the IO object.</span>

<span class="sd">        This method has no effect if the file is already closed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__closed</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c"># If flush() fails, just give up</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__closed</span> <span class="o">=</span> <span class="bp">True</span>
</div>
    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Destructor.  Calls close().&quot;&quot;&quot;</span>
        <span class="c"># The try/except block is in case this is called at program</span>
        <span class="c"># exit time, when it&#39;s possible that globals have already been</span>
        <span class="c"># deleted, and then the close() call might fail.  Since</span>
        <span class="c"># there&#39;s nothing we can do about such failures and they annoy</span>
        <span class="c"># the end users, we suppress the traceback.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="c">### Inquiries ###</span>

<div class="viewcode-block" id="IOBase.seekable"><a class="viewcode-back" href="../api.html#io.IOBase.seekable">[docs]</a>    <span class="k">def</span> <span class="nf">seekable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether object supports random access.</span>

<span class="sd">        If False, seek(), tell() and truncate() will raise IOError.</span>
<span class="sd">        This method may need to do a test seek().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
    <span class="k">def</span> <span class="nf">_checkSeekable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Internal: raise an IOError if file is not seekable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">seekable</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s">&quot;File or stream is not seekable.&quot;</span>
                          <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">msg</span><span class="p">)</span>


<div class="viewcode-block" id="IOBase.readable"><a class="viewcode-back" href="../api.html#io.IOBase.readable">[docs]</a>    <span class="k">def</span> <span class="nf">readable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether object was opened for reading.</span>

<span class="sd">        If False, read() will raise IOError.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
    <span class="k">def</span> <span class="nf">_checkReadable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Internal: raise an IOError if file is not readable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">readable</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s">&quot;File or stream is not readable.&quot;</span>
                          <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">msg</span><span class="p">)</span>

<div class="viewcode-block" id="IOBase.writable"><a class="viewcode-back" href="../api.html#io.IOBase.writable">[docs]</a>    <span class="k">def</span> <span class="nf">writable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether object was opened for writing.</span>

<span class="sd">        If False, write() and truncate() will raise IOError.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
    <span class="k">def</span> <span class="nf">_checkWritable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Internal: raise an IOError if file is not writable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">writable</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s">&quot;File or stream is not writable.&quot;</span>
                          <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">msg</span><span class="p">)</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="IOBase.closed"><a class="viewcode-back" href="../api.html#io.IOBase.closed">[docs]</a>    <span class="k">def</span> <span class="nf">closed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;closed: bool.  True iff the file has been closed.</span>

<span class="sd">        For backwards compatibility, this is a property, not a predicate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__closed</span>
</div>
    <span class="k">def</span> <span class="nf">_checkClosed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Internal: raise an ValueError if file is closed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;I/O operation on closed file.&quot;</span>
                             <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">msg</span><span class="p">)</span>

    <span class="c">### Context manager ###</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Context management protocol.  Returns self.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_checkClosed</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Context management protocol.  Calls close()&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c">### Lower-level APIs ###</span>

    <span class="c"># XXX Should these be present even if unimplemented?</span>

<div class="viewcode-block" id="IOBase.fileno"><a class="viewcode-back" href="../api.html#io.IOBase.fileno">[docs]</a>    <span class="k">def</span> <span class="nf">fileno</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns underlying file descriptor if one exists.</span>

<span class="sd">        An IOError is raised if the IO object does not use a file descriptor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsupported</span><span class="p">(</span><span class="s">&quot;fileno&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="IOBase.isatty"><a class="viewcode-back" href="../api.html#io.IOBase.isatty">[docs]</a>    <span class="k">def</span> <span class="nf">isatty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether this is an &#39;interactive&#39; stream.</span>

<span class="sd">        Return False if it can&#39;t be determined.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_checkClosed</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="c">### Readline[s] and writelines ###</span>
</div>
<div class="viewcode-block" id="IOBase.readline"><a class="viewcode-back" href="../api.html#io.IOBase.readline">[docs]</a>    <span class="k">def</span> <span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="s">r&quot;&quot;&quot;Read and return a line from the stream.</span>

<span class="s">        If limit is specified, at most limit bytes will be read.</span>

<span class="s">        The line terminator is always b&#39;\n&#39; for binary files; for text</span>
<span class="s">        files, the newlines argument to open can be used to select the line</span>
<span class="s">        terminator(s) recognized.</span>
<span class="s">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_checkClosed</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;peek&quot;</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">nreadahead</span><span class="p">():</span>
                <span class="n">readahead</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">readahead</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">1</span>
                <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">readahead</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">readahead</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">limit</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">n</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">nreadahead</span><span class="p">():</span>
                <span class="k">return</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">limit</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;limit must be an integer&quot;</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">limit</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">nreadahead</span><span class="p">())</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">b</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">b</span>
            <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">b</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">):</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_checkClosed</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
        <span class="k">return</span> <span class="n">line</span>

<div class="viewcode-block" id="IOBase.readlines"><a class="viewcode-back" href="../api.html#io.IOBase.readlines">[docs]</a>    <span class="k">def</span> <span class="nf">readlines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of lines from the stream.</span>

<span class="sd">        hint can be specified to control the number of lines read: no more</span>
<span class="sd">        lines will be read if the total size (in bytes/characters) of all</span>
<span class="sd">        lines so far exceeds hint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">hint</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">hint</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hint</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;hint must be an integer&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hint</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="n">hint</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">lines</span>
</div>
    <span class="k">def</span> <span class="nf">writelines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_checkClosed</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="RawIOBase"><a class="viewcode-back" href="../api.html#io.RawIOBase">[docs]</a><span class="k">class</span> <span class="nc">RawIOBase</span><span class="p">(</span><span class="n">IOBase</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Base class for raw binary I/O.&quot;&quot;&quot;</span>

    <span class="c"># The read() method is implemented by calling readinto(); derived</span>
    <span class="c"># classes that want to support read() only need to implement</span>
    <span class="c"># readinto() as a primitive operation.  In general, readinto() can be</span>
    <span class="c"># more efficient than read().</span>

    <span class="c"># (It would be tempting to also provide an implementation of</span>
    <span class="c"># readinto() in terms of read(), in case the latter is a more suitable</span>
    <span class="c"># primitive operation, but that would lead to nasty recursion in case</span>
    <span class="c"># a subclass doesn&#39;t implement either.)</span>

<div class="viewcode-block" id="RawIOBase.read"><a class="viewcode-back" href="../api.html#io.RawIOBase.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read and return up to n bytes.</span>

<span class="sd">        Returns an empty bytes array on EOF, or None if the object is</span>
<span class="sd">        set not to block and has no data to read.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">readall</span><span class="p">()</span>
        <span class="n">b</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">__index__</span><span class="p">())</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">readinto</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">b</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span>
        <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="RawIOBase.readall"><a class="viewcode-back" href="../api.html#io.RawIOBase.readall">[docs]</a>    <span class="k">def</span> <span class="nf">readall</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read until EOF, using multiple read() call.&quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">DEFAULT_BUFFER_SIZE</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">data</span>
        <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="RawIOBase.readinto"><a class="viewcode-back" href="../api.html#io.RawIOBase.readinto">[docs]</a>    <span class="k">def</span> <span class="nf">readinto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read up to len(b) bytes into b.</span>

<span class="sd">        Returns number of bytes read (0 for EOF), or None if the object</span>
<span class="sd">        is set not to block as has no data to read.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsupported</span><span class="p">(</span><span class="s">&quot;readinto&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="RawIOBase.write"><a class="viewcode-back" href="../api.html#io.RawIOBase.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the given buffer to the IO stream.</span>

<span class="sd">        Returns the number of bytes written, which may be less than len(b).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsupported</span><span class="p">(</span><span class="s">&quot;write&quot;</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="FileIO"><a class="viewcode-back" href="../api.html#io.FileIO">[docs]</a><span class="k">class</span> <span class="nc">FileIO</span><span class="p">(</span><span class="n">_fileio</span><span class="o">.</span><span class="n">_FileIO</span><span class="p">,</span> <span class="n">RawIOBase</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Raw I/O implementation for OS files.&quot;&quot;&quot;</span>

    <span class="c"># This multiply inherits from _FileIO and RawIOBase to make</span>
    <span class="c"># isinstance(io.FileIO(), io.RawIOBase) return True without requiring</span>
    <span class="c"># that _fileio._FileIO inherits from io.RawIOBase (which would be hard</span>
    <span class="c"># to do since _fileio.c is written in C).</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&quot;r&quot;</span><span class="p">,</span> <span class="n">closefd</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="n">_fileio</span><span class="o">.</span><span class="n">_FileIO</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">closefd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_fileio</span><span class="o">.</span><span class="n">_FileIO</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">RawIOBase</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

</div>
<div class="viewcode-block" id="BufferedIOBase"><a class="viewcode-back" href="../api.html#io.BufferedIOBase">[docs]</a><span class="k">class</span> <span class="nc">BufferedIOBase</span><span class="p">(</span><span class="n">IOBase</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Base class for buffered IO objects.</span>

<span class="sd">    The main difference with RawIOBase is that the read() method</span>
<span class="sd">    supports omitting the size argument, and does not have a default</span>
<span class="sd">    implementation that defers to readinto().</span>

<span class="sd">    In addition, read(), readinto() and write() may raise</span>
<span class="sd">    BlockingIOError if the underlying raw stream is in non-blocking</span>
<span class="sd">    mode and not ready; unlike their raw counterparts, they will never</span>
<span class="sd">    return None.</span>

<span class="sd">    A typical implementation should not inherit from a RawIOBase</span>
<span class="sd">    implementation, but wrap one.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BufferedIOBase.read"><a class="viewcode-back" href="../api.html#io.BufferedIOBase.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read and return up to n bytes.</span>

<span class="sd">        If the argument is omitted, None, or negative, reads and</span>
<span class="sd">        returns all data until EOF.</span>

<span class="sd">        If the argument is positive, and the underlying raw stream is</span>
<span class="sd">        not &#39;interactive&#39;, multiple raw reads may be issued to satisfy</span>
<span class="sd">        the byte count (unless EOF is reached first).  But for</span>
<span class="sd">        interactive raw streams (XXX and for pipes?), at most one raw</span>
<span class="sd">        read will be issued, and a short result does not imply that</span>
<span class="sd">        EOF is imminent.</span>

<span class="sd">        Returns an empty bytes array on EOF.</span>

<span class="sd">        Raises BlockingIOError if the underlying raw stream has no</span>
<span class="sd">        data at the moment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsupported</span><span class="p">(</span><span class="s">&quot;read&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BufferedIOBase.readinto"><a class="viewcode-back" href="../api.html#io.BufferedIOBase.readinto">[docs]</a>    <span class="k">def</span> <span class="nf">readinto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read up to len(b) bytes into b.</span>

<span class="sd">        Like read(), this may issue multiple reads to the underlying raw</span>
<span class="sd">        stream, unless the latter is &#39;interactive&#39;.</span>

<span class="sd">        Returns the number of bytes read (0 for EOF).</span>

<span class="sd">        Raises BlockingIOError if the underlying raw stream has no</span>
<span class="sd">        data at the moment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># XXX This ought to work with anything that supports the buffer API</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">b</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">array</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">err</span>
            <span class="n">b</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">b</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n</span>
</div>
<div class="viewcode-block" id="BufferedIOBase.write"><a class="viewcode-back" href="../api.html#io.BufferedIOBase.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the given buffer to the IO stream.</span>

<span class="sd">        Return the number of bytes written, which is never less than</span>
<span class="sd">        len(b).</span>

<span class="sd">        Raises BlockingIOError if the buffer is full and the</span>
<span class="sd">        underlying raw stream cannot accept more data at the moment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsupported</span><span class="p">(</span><span class="s">&quot;write&quot;</span><span class="p">)</span>

</div></div>
<span class="k">class</span> <span class="nc">_BufferedIOMixin</span><span class="p">(</span><span class="n">BufferedIOBase</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;A mixin implementation of BufferedIOBase with an underlying raw stream.</span>

<span class="sd">    This passes most requests on to the underlying raw stream.  It</span>
<span class="sd">    does *not* provide implementations of read(), readinto() or</span>
<span class="sd">    write().</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw</span> <span class="o">=</span> <span class="n">raw</span>

    <span class="c">### Positioning ###</span>

    <span class="k">def</span> <span class="nf">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">whence</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">whence</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c"># Flush the stream.  We&#39;re mixing buffered I/O with lower-level I/O,</span>
        <span class="c"># and a flush may be necessary to synch both views of the current</span>
        <span class="c"># file state.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="c"># XXX: Should seek() be used, instead of passing the position</span>
        <span class="c"># XXX  directly to truncate?</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>

    <span class="c">### Flush and close ###</span>

    <span class="k">def</span> <span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c"># If flush() fails, just give up</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c">### Inquiries ###</span>

    <span class="k">def</span> <span class="nf">seekable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">seekable</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">readable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">readable</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">writable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">writable</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">closed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">closed</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">mode</span>

    <span class="c">### Lower-level APIs ###</span>

    <span class="k">def</span> <span class="nf">fileno</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">fileno</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">isatty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">isatty</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">_BytesIO</span><span class="p">(</span><span class="n">BufferedIOBase</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Buffered I/O implementation using an in-memory bytes buffer.&quot;&quot;&quot;</span>

    <span class="c"># XXX More docs</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_bytes</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">initial_bytes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">+=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">initial_bytes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span> <span class="o">=</span> <span class="n">buf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">getvalue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the bytes value (contents) of the buffer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;getvalue on closed file&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;read from closed file&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;argument must be an integer&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span><span class="s">&quot;&quot;</span>
        <span class="n">newpos</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="p">:</span> <span class="n">newpos</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">=</span> <span class="n">newpos</span>
        <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;this is the same as read.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;write to closed file&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">unicode</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;can&#39;t write unicode to binary stream&quot;</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">):</span>
            <span class="c"># Inserts null bytes between the current end of the file</span>
            <span class="c"># and the new write position.</span>
            <span class="n">padding</span> <span class="o">=</span> <span class="n">b</span><span class="s">&#39;</span><span class="se">\x00</span><span class="s">&#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span> <span class="o">+=</span> <span class="n">padding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="n">pos</span><span class="p">:</span><span class="n">pos</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">+=</span> <span class="n">n</span>
        <span class="k">return</span> <span class="n">n</span>

    <span class="k">def</span> <span class="nf">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">whence</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;seek on closed file&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="o">.</span><span class="n">__index__</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;an integer is required&quot;</span><span class="p">)</span> <span class="c"># from err</span>
        <span class="k">if</span> <span class="n">whence</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;negative seek position </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pos</span><span class="p">,))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="k">elif</span> <span class="n">whence</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">+</span> <span class="n">pos</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">whence</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">)</span> <span class="o">+</span> <span class="n">pos</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;invalid whence value&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span>

    <span class="k">def</span> <span class="nf">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;tell on closed file&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span>

    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;truncate on closed file&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;negative truncate position </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pos</span><span class="p">,))</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">[</span><span class="n">pos</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">pos</span>

    <span class="k">def</span> <span class="nf">readable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">writable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">seekable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>

<span class="c"># Use the faster implementation of BytesIO if available</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">_bytesio</span>

<div class="viewcode-block" id="BytesIO"><a class="viewcode-back" href="../api.html#io.BytesIO">[docs]</a>    <span class="k">class</span> <span class="nc">BytesIO</span><span class="p">(</span><span class="n">_bytesio</span><span class="o">.</span><span class="n">_BytesIO</span><span class="p">,</span> <span class="n">BufferedIOBase</span><span class="p">):</span>
        <span class="n">__doc__</span> <span class="o">=</span> <span class="n">_bytesio</span><span class="o">.</span><span class="n">_BytesIO</span><span class="o">.</span><span class="n">__doc__</span>
</div>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">BytesIO</span> <span class="o">=</span> <span class="n">_BytesIO</span>


<div class="viewcode-block" id="BufferedReader"><a class="viewcode-back" href="../api.html#io.BufferedReader">[docs]</a><span class="k">class</span> <span class="nc">BufferedReader</span><span class="p">(</span><span class="n">_BufferedIOMixin</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;BufferedReader(raw[, buffer_size])</span>

<span class="sd">    A buffer for a readable, sequential BaseRawIO object.</span>

<span class="sd">    The constructor creates a BufferedReader for the given readable raw</span>
<span class="sd">    stream and buffer_size. If buffer_size is omitted, DEFAULT_BUFFER_SIZE</span>
<span class="sd">    is used.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">buffer_size</span><span class="o">=</span><span class="n">DEFAULT_BUFFER_SIZE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new buffered reader using the given readable raw IO object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raw</span><span class="o">.</span><span class="n">_checkReadable</span><span class="p">()</span>
        <span class="n">_BufferedIOMixin</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="n">buffer_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_read_buf</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_reset_read_buf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_buf</span> <span class="o">=</span> <span class="n">b</span><span class="s">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_pos</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="BufferedReader.read"><a class="viewcode-back" href="../api.html#io.BufferedReader.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read n bytes.</span>

<span class="sd">        Returns exactly n bytes of data unless the underlying raw IO</span>
<span class="sd">        stream reaches EOF or if the call would block in non-blocking</span>
<span class="sd">        mode. If n is negative, read until EOF or until read() would</span>
<span class="sd">        block.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_lock</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_unlocked</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_read_unlocked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">nodata_val</span> <span class="o">=</span> <span class="n">b</span><span class="s">&quot;&quot;</span>
        <span class="n">empty_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buf</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_pos</span>

        <span class="c"># Special case for when the number of bytes to read is unspecified.</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reset_read_buf</span><span class="p">()</span>
            <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">buf</span><span class="p">[</span><span class="n">pos</span><span class="p">:]]</span>  <span class="c"># Strip the consumed bytes.</span>
            <span class="n">current_size</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="c"># Read until EOF or until read() would block.</span>
                <span class="n">chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">empty_values</span><span class="p">:</span>
                    <span class="n">nodata_val</span> <span class="o">=</span> <span class="n">chunk</span>
                    <span class="k">break</span>
                <span class="n">current_size</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
                <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">b</span><span class="s">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span> <span class="ow">or</span> <span class="n">nodata_val</span>

        <span class="c"># The number of bytes to read is specified, return at most n bytes.</span>
        <span class="n">avail</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">-</span> <span class="n">pos</span>  <span class="c"># Length of the available buffered data.</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">avail</span><span class="p">:</span>
            <span class="c"># Fast path: the data to read is fully buffered.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_pos</span> <span class="o">+=</span> <span class="n">n</span>
            <span class="k">return</span> <span class="n">buf</span><span class="p">[</span><span class="n">pos</span><span class="p">:</span><span class="n">pos</span><span class="o">+</span><span class="n">n</span><span class="p">]</span>
        <span class="c"># Slow path: read from the stream until enough bytes are read,</span>
        <span class="c"># or until an EOF occurs or until read() would block.</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">buf</span><span class="p">[</span><span class="n">pos</span><span class="p">:]]</span>
        <span class="n">wanted</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">avail</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">wanted</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">empty_values</span><span class="p">:</span>
                <span class="n">nodata_val</span> <span class="o">=</span> <span class="n">chunk</span>
                <span class="k">break</span>
            <span class="n">avail</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
            <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="c"># n is more then avail only when an EOF occurred or when</span>
        <span class="c"># read() would have blocked.</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">avail</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">b</span><span class="s">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_buf</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span>  <span class="c"># Save the extra data in the buffer.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_read_pos</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="k">if</span> <span class="n">out</span> <span class="k">else</span> <span class="n">nodata_val</span>

<div class="viewcode-block" id="BufferedReader.peek"><a class="viewcode-back" href="../api.html#io.BufferedReader.peek">[docs]</a>    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns buffered bytes without advancing the position.</span>

<span class="sd">        The argument indicates a desired minimal number of bytes; we</span>
<span class="sd">        do at most one raw read to satisfy it.  We never return more</span>
<span class="sd">        than self.buffer_size.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_lock</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_peek_unlocked</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_peek_unlocked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">want</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span><span class="p">)</span>
        <span class="n">have</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_buf</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_pos</span>
        <span class="k">if</span> <span class="n">have</span> <span class="o">&lt;</span> <span class="n">want</span><span class="p">:</span>
            <span class="n">to_read</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span> <span class="o">-</span> <span class="n">have</span>
            <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">to_read</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">current</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_read_buf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_pos</span><span class="p">:]</span> <span class="o">+</span> <span class="n">current</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_read_pos</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_pos</span><span class="p">:]</span>

<div class="viewcode-block" id="BufferedReader.read1"><a class="viewcode-back" href="../api.html#io.BufferedReader.read1">[docs]</a>    <span class="k">def</span> <span class="nf">read1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reads up to n bytes, with at most one read() system call.&quot;&quot;&quot;</span>
        <span class="c"># Returns up to n bytes.  If at least one byte is buffered, we</span>
        <span class="c"># only return buffered bytes.  Otherwise, we do one raw read.</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span><span class="s">&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_peek_unlocked</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_unlocked</span><span class="p">(</span>
                <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_buf</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_pos</span><span class="p">))</span>
</div>
    <span class="k">def</span> <span class="nf">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_buf</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_pos</span>

    <span class="k">def</span> <span class="nf">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">whence</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">whence</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_buf</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_pos</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">whence</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reset_read_buf</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">pos</span>

</div>
<div class="viewcode-block" id="BufferedWriter"><a class="viewcode-back" href="../api.html#io.BufferedWriter">[docs]</a><span class="k">class</span> <span class="nc">BufferedWriter</span><span class="p">(</span><span class="n">_BufferedIOMixin</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;A buffer for a writeable sequential RawIO object.</span>

<span class="sd">    The constructor creates a BufferedWriter for the given writeable raw</span>
<span class="sd">    stream. If the buffer_size is not given, it defaults to</span>
<span class="sd">    DEAFULT_BUFFER_SIZE. If max_buffer_size is omitted, it defaults to</span>
<span class="sd">    twice the buffer size.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span>
                 <span class="n">buffer_size</span><span class="o">=</span><span class="n">DEFAULT_BUFFER_SIZE</span><span class="p">,</span> <span class="n">max_buffer_size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">raw</span><span class="o">.</span><span class="n">_checkWritable</span><span class="p">()</span>
        <span class="n">_BufferedIOMixin</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="n">buffer_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_buffer_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">buffer_size</span>
                                <span class="k">if</span> <span class="n">max_buffer_size</span> <span class="ow">is</span> <span class="bp">None</span>
                                <span class="k">else</span> <span class="n">max_buffer_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;write to closed file&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">unicode</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;can&#39;t write unicode to binary stream&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_lock</span><span class="p">:</span>
            <span class="c"># XXX we can implement some more tricks to try and avoid</span>
            <span class="c"># partial writes</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span><span class="p">:</span>
                <span class="c"># We&#39;re full, so let&#39;s pre-flush the buffer</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_flush_unlocked</span><span class="p">()</span>
                <span class="k">except</span> <span class="n">BlockingIOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="c"># We can&#39;t accept anything else.</span>
                    <span class="c"># XXX Why not just let the exception pass through?</span>
                    <span class="k">raise</span> <span class="n">BlockingIOError</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">errno</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">strerror</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">before</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">written</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="p">)</span> <span class="o">-</span> <span class="n">before</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_flush_unlocked</span><span class="p">()</span>
                <span class="k">except</span> <span class="n">BlockingIOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_buffer_size</span><span class="p">:</span>
                        <span class="c"># We&#39;ve hit max_buffer_size. We have to accept a</span>
                        <span class="c"># partial write and cut back our buffer.</span>
                        <span class="n">overage</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_buffer_size</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">max_buffer_size</span><span class="p">]</span>
                        <span class="k">raise</span> <span class="n">BlockingIOError</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">errno</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">strerror</span><span class="p">,</span> <span class="n">overage</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">written</span>

    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flush_unlocked</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flush_unlocked</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_flush_unlocked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;flush of closed file&quot;</span><span class="p">)</span>
        <span class="n">written</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="p">)</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
                <span class="n">written</span> <span class="o">+=</span> <span class="n">n</span>
        <span class="k">except</span> <span class="n">BlockingIOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">characters_written</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
            <span class="n">written</span> <span class="o">+=</span> <span class="n">n</span>
            <span class="k">raise</span> <span class="n">BlockingIOError</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">errno</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">strerror</span><span class="p">,</span> <span class="n">written</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">whence</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flush_unlocked</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">whence</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="BufferedRWPair"><a class="viewcode-back" href="../api.html#io.BufferedRWPair">[docs]</a><span class="k">class</span> <span class="nc">BufferedRWPair</span><span class="p">(</span><span class="n">BufferedIOBase</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;A buffered reader and writer object together.</span>

<span class="sd">    A buffered reader object and buffered writer object put together to</span>
<span class="sd">    form a sequential IO object that can read and write. This is typically</span>
<span class="sd">    used with a socket or two-way pipe.</span>

<span class="sd">    reader and writer are RawIOBase objects that are readable and</span>
<span class="sd">    writeable respectively. If the buffer_size is omitted it defaults to</span>
<span class="sd">    DEFAULT_BUFFER_SIZE. The max_buffer_size (for the buffered writer)</span>
<span class="sd">    defaults to twice the buffer size.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># XXX The usefulness of this (compared to having two separate IO</span>
    <span class="c"># objects) is questionable.</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader</span><span class="p">,</span> <span class="n">writer</span><span class="p">,</span>
                 <span class="n">buffer_size</span><span class="o">=</span><span class="n">DEFAULT_BUFFER_SIZE</span><span class="p">,</span> <span class="n">max_buffer_size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor.</span>

<span class="sd">        The arguments are two RawIO instances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reader</span><span class="o">.</span><span class="n">_checkReadable</span><span class="p">()</span>
        <span class="n">writer</span><span class="o">.</span><span class="n">_checkWritable</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reader</span> <span class="o">=</span> <span class="n">BufferedReader</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writer</span> <span class="o">=</span> <span class="n">BufferedWriter</span><span class="p">(</span><span class="n">writer</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">,</span> <span class="n">max_buffer_size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">readinto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">readinto</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">read1</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">readable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">readable</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">writable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="o">.</span><span class="n">writable</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">isatty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">isatty</span><span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="o">.</span><span class="n">isatty</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">closed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">writer</span><span class="o">.</span><span class="n">closed</span>

</div>
<div class="viewcode-block" id="BufferedRandom"><a class="viewcode-back" href="../api.html#io.BufferedRandom">[docs]</a><span class="k">class</span> <span class="nc">BufferedRandom</span><span class="p">(</span><span class="n">BufferedWriter</span><span class="p">,</span> <span class="n">BufferedReader</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;A buffered interface to random access streams.</span>

<span class="sd">    The constructor creates a reader and writer for a seekable stream,</span>
<span class="sd">    raw, given in the first argument. If the buffer_size is omitted it</span>
<span class="sd">    defaults to DEFAULT_BUFFER_SIZE. The max_buffer_size (for the buffered</span>
<span class="sd">    writer) defaults to twice the buffer size.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span>
                 <span class="n">buffer_size</span><span class="o">=</span><span class="n">DEFAULT_BUFFER_SIZE</span><span class="p">,</span> <span class="n">max_buffer_size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">raw</span><span class="o">.</span><span class="n">_checkSeekable</span><span class="p">()</span>
        <span class="n">BufferedReader</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">)</span>
        <span class="n">BufferedWriter</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">,</span> <span class="n">max_buffer_size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">whence</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="c"># First do the raw seek, then empty the read buffer, so that</span>
        <span class="c"># if the raw seek fails, we don&#39;t lose buffered data forever.</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">whence</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reset_read_buf</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">pos</span>

    <span class="k">def</span> <span class="nf">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_write_buf</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BufferedReader</span><span class="o">.</span><span class="n">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="c"># Use seek to flush the read buffer.</span>
        <span class="k">return</span> <span class="n">BufferedWriter</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">BufferedReader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">readinto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">BufferedReader</span><span class="o">.</span><span class="n">readinto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">peek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">BufferedReader</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">BufferedReader</span><span class="o">.</span><span class="n">read1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_buf</span><span class="p">:</span>
            <span class="c"># Undo readahead</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_lock</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_pos</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_read_buf</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reset_read_buf</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">BufferedWriter</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="TextIOBase"><a class="viewcode-back" href="../api.html#io.TextIOBase">[docs]</a><span class="k">class</span> <span class="nc">TextIOBase</span><span class="p">(</span><span class="n">IOBase</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Base class for text I/O.</span>

<span class="sd">    This class provides a character and line based interface to stream</span>
<span class="sd">    I/O. There is no readinto method because Python&#39;s character strings</span>
<span class="sd">    are immutable. There is no public constructor.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TextIOBase.read"><a class="viewcode-back" href="../api.html#io.TextIOBase.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read at most n characters from stream.</span>

<span class="sd">        Read from underlying buffer until we have n characters or we hit EOF.</span>
<span class="sd">        If n is negative or omitted, read until EOF.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsupported</span><span class="p">(</span><span class="s">&quot;read&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TextIOBase.write"><a class="viewcode-back" href="../api.html#io.TextIOBase.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write string s to stream.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsupported</span><span class="p">(</span><span class="s">&quot;write&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TextIOBase.truncate"><a class="viewcode-back" href="../api.html#io.TextIOBase.truncate">[docs]</a>    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Truncate size to pos.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsupported</span><span class="p">(</span><span class="s">&quot;truncate&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TextIOBase.readline"><a class="viewcode-back" href="../api.html#io.TextIOBase.readline">[docs]</a>    <span class="k">def</span> <span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read until newline or EOF.</span>

<span class="sd">        Returns an empty string if EOF is hit immediately.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsupported</span><span class="p">(</span><span class="s">&quot;readline&quot;</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="TextIOBase.encoding"><a class="viewcode-back" href="../api.html#io.TextIOBase.encoding">[docs]</a>    <span class="k">def</span> <span class="nf">encoding</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Subclasses should override.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">None</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="TextIOBase.newlines"><a class="viewcode-back" href="../api.html#io.TextIOBase.newlines">[docs]</a>    <span class="k">def</span> <span class="nf">newlines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Line endings translated so far.</span>

<span class="sd">        Only line endings translated during reading are considered.</span>

<span class="sd">        Subclasses should override.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">None</span>

</div></div>
<span class="k">class</span> <span class="nc">IncrementalNewlineDecoder</span><span class="p">(</span><span class="n">codecs</span><span class="o">.</span><span class="n">IncrementalDecoder</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Codec used when reading a file in universal newlines mode.</span>
<span class="sd">    It wraps another incremental decoder, translating \\r\\n and \\r into \\n.</span>
<span class="sd">    It also records the types of newlines encountered.</span>
<span class="sd">    When used with translate=False, it ensures that the newline sequence is</span>
<span class="sd">    returned in one piece.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decoder</span><span class="p">,</span> <span class="n">translate</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s">&#39;strict&#39;</span><span class="p">):</span>
        <span class="n">codecs</span><span class="o">.</span><span class="n">IncrementalDecoder</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">translate</span> <span class="o">=</span> <span class="n">translate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span> <span class="o">=</span> <span class="n">decoder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seennl</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pendingcr</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">final</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="c"># decode input (with the eventual \r from a previous pass)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">final</span><span class="o">=</span><span class="n">final</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pendingcr</span> <span class="ow">and</span> <span class="p">(</span><span class="n">output</span> <span class="ow">or</span> <span class="n">final</span><span class="p">):</span>
            <span class="n">output</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\r</span><span class="s">&quot;</span> <span class="o">+</span> <span class="n">output</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pendingcr</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c"># retain last \r even when not translating data:</span>
        <span class="c"># then readline() is sure to get \r\n in one pass</span>
        <span class="k">if</span> <span class="n">output</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">final</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pendingcr</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c"># Record which newlines are read</span>
        <span class="n">crlf</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\r\n</span><span class="s">&#39;</span><span class="p">)</span>
        <span class="n">cr</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\r</span><span class="s">&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">crlf</span>
        <span class="n">lf</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">crlf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seennl</span> <span class="o">|=</span> <span class="p">(</span><span class="n">lf</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_LF</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">cr</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CR</span><span class="p">)</span> \
                    <span class="o">|</span> <span class="p">(</span><span class="n">crlf</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CRLF</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">crlf</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cr</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">getstate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">buf</span><span class="p">,</span> <span class="n">flag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">getstate</span><span class="p">()</span>
        <span class="n">flag</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pendingcr</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">|=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">buf</span><span class="p">,</span> <span class="n">flag</span>

    <span class="k">def</span> <span class="nf">setstate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">buf</span><span class="p">,</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pendingcr</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">setstate</span><span class="p">((</span><span class="n">buf</span><span class="p">,</span> <span class="n">flag</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seennl</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pendingcr</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

    <span class="n">_LF</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">_CR</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">_CRLF</span> <span class="o">=</span> <span class="mi">4</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">newlines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span>
                <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                <span class="s">&quot;</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">,</span>
                <span class="p">(</span><span class="s">&quot;</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">),</span>
                <span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">,</span>
                <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">),</span>
                <span class="p">(</span><span class="s">&quot;</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">),</span>
                <span class="p">(</span><span class="s">&quot;</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">)</span>
               <span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">seennl</span><span class="p">]</span>


<div class="viewcode-block" id="TextIOWrapper"><a class="viewcode-back" href="../api.html#io.TextIOWrapper">[docs]</a><span class="k">class</span> <span class="nc">TextIOWrapper</span><span class="p">(</span><span class="n">TextIOBase</span><span class="p">):</span>

    <span class="s">r&quot;&quot;&quot;Character and line based layer over a BufferedIOBase object, buffer.</span>

<span class="s">    encoding gives the name of the encoding that the stream will be</span>
<span class="s">    decoded or encoded with. It defaults to locale.getpreferredencoding.</span>

<span class="s">    errors determines the strictness of encoding and decoding (see the</span>
<span class="s">    codecs.register) and defaults to &quot;strict&quot;.</span>

<span class="s">    newline can be None, &#39;&#39;, &#39;\n&#39;, &#39;\r&#39;, or &#39;\r\n&#39;.  It controls the</span>
<span class="s">    handling of line endings. If it is None, universal newlines is</span>
<span class="s">    enabled.  With this enabled, on input, the lines endings &#39;\n&#39;, &#39;\r&#39;,</span>
<span class="s">    or &#39;\r\n&#39; are translated to &#39;\n&#39; before being returned to the</span>
<span class="s">    caller. Conversely, on output, &#39;\n&#39; is translated to the system</span>
<span class="s">    default line separator, os.linesep. If newline is any other of its</span>
<span class="s">    legal values, that newline becomes the newline when the file is read</span>
<span class="s">    and it is returned untranslated. On output, &#39;\n&#39; is converted to the</span>
<span class="s">    newline.</span>

<span class="s">    If line_buffering is True, a call to flush is implied when a call to</span>
<span class="s">    write contains a newline character.</span>
<span class="s">    &quot;&quot;&quot;</span>

    <span class="n">_CHUNK_SIZE</span> <span class="o">=</span> <span class="mi">128</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">buffer</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">line_buffering</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">newline</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;illegal newline value: </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">newline</span><span class="p">,))</span>
        <span class="k">if</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">encoding</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">device_encoding</span><span class="p">(</span><span class="nb">buffer</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="n">UnsupportedOperation</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">if</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="kn">import</span> <span class="nn">locale</span>
                <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                    <span class="c"># Importing locale may fail if Python is being built</span>
                    <span class="n">encoding</span> <span class="o">=</span> <span class="s">&quot;ascii&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">encoding</span> <span class="o">=</span> <span class="n">locale</span><span class="o">.</span><span class="n">getpreferredencoding</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">encoding</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;invalid encoding: </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">encoding</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">errors</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">errors</span> <span class="o">=</span> <span class="s">&quot;strict&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">errors</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;invalid errors: </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">errors</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="nb">buffer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_line_buffering</span> <span class="o">=</span> <span class="n">line_buffering</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span> <span class="o">=</span> <span class="n">encoding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_errors</span> <span class="o">=</span> <span class="n">errors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_readuniversal</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">newline</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_readtranslate</span> <span class="o">=</span> <span class="n">newline</span> <span class="ow">is</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_readnl</span> <span class="o">=</span> <span class="n">newline</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_writetranslate</span> <span class="o">=</span> <span class="n">newline</span> <span class="o">!=</span> <span class="s">&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_writenl</span> <span class="o">=</span> <span class="n">newline</span> <span class="ow">or</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_encoder</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>  <span class="c"># buffer for text returned from decoder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars_used</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># offset into _decoded_chars for read()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># info for reconstructing decoder state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_seekable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_telling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">seekable</span><span class="p">()</span>

    <span class="c"># self._snapshot is either None, or a tuple (dec_flags, next_input)</span>
    <span class="c"># where dec_flags is the second (integer) item of the decoder state</span>
    <span class="c"># and next_input is the chunk of input bytes that comes next after the</span>
    <span class="c"># snapshot point.  We use this to reconstruct decoder states in tell().</span>

    <span class="c"># Naming convention:</span>
    <span class="c">#   - &quot;bytes_...&quot; for integer variables that count input bytes</span>
    <span class="c">#   - &quot;chars_...&quot; for integer variables that count decoded characters</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">encoding</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">errors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_errors</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">line_buffering</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line_buffering</span>

    <span class="k">def</span> <span class="nf">seekable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seekable</span>

    <span class="k">def</span> <span class="nf">readable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">readable</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">writable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">writable</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_telling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seekable</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c"># If flush() fails, just give up</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">closed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">closed</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">fileno</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">fileno</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">isatty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">isatty</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;write to closed file&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">unicode</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;can&#39;t write </span><span class="si">%s</span><span class="s"> to text stream&quot;</span> <span class="o">%</span>
                            <span class="n">s</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">haslf</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_writetranslate</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line_buffering</span><span class="p">)</span> <span class="ow">and</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="ow">in</span> <span class="n">s</span>
        <span class="k">if</span> <span class="n">haslf</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_writetranslate</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_writenl</span> <span class="o">!=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_writenl</span><span class="p">)</span>
        <span class="n">encoder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encoder</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_encoder</span><span class="p">()</span>
        <span class="c"># XXX What if we were just reading?</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">encoder</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line_buffering</span> <span class="ow">and</span> <span class="p">(</span><span class="n">haslf</span> <span class="ow">or</span> <span class="s">&quot;</span><span class="se">\r</span><span class="s">&quot;</span> <span class="ow">in</span> <span class="n">s</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">length</span>

    <span class="k">def</span> <span class="nf">_get_encoder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">make_encoder</span> <span class="o">=</span> <span class="n">codecs</span><span class="o">.</span><span class="n">getincrementalencoder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_encoder</span> <span class="o">=</span> <span class="n">make_encoder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_errors</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encoder</span>

    <span class="k">def</span> <span class="nf">_get_decoder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">make_decoder</span> <span class="o">=</span> <span class="n">codecs</span><span class="o">.</span><span class="n">getincrementaldecoder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span><span class="p">)</span>
        <span class="n">decoder</span> <span class="o">=</span> <span class="n">make_decoder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_errors</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_readuniversal</span><span class="p">:</span>
            <span class="n">decoder</span> <span class="o">=</span> <span class="n">IncrementalNewlineDecoder</span><span class="p">(</span><span class="n">decoder</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_readtranslate</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span> <span class="o">=</span> <span class="n">decoder</span>
        <span class="k">return</span> <span class="n">decoder</span>

    <span class="c"># The following three methods implement an ADT for _decoded_chars.</span>
    <span class="c"># Text returned from the decoder is buffered here until the client</span>
    <span class="c"># requests it by calling our read() or readline() method.</span>
    <span class="k">def</span> <span class="nf">_set_decoded_chars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chars</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the _decoded_chars buffer.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars</span> <span class="o">=</span> <span class="n">chars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars_used</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_get_decoded_chars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Advance into the _decoded_chars buffer.&quot;&quot;&quot;</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars_used</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">chars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars</span><span class="p">[</span><span class="n">offset</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars</span><span class="p">[</span><span class="n">offset</span><span class="p">:</span><span class="n">offset</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars_used</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">chars</span>

    <span class="k">def</span> <span class="nf">_rewind_decoded_chars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rewind the _decoded_chars buffer.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars_used</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s">&quot;rewind decoded_chars out of bounds&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars_used</span> <span class="o">-=</span> <span class="n">n</span>

    <span class="k">def</span> <span class="nf">_read_chunk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read and decode the next chunk of data from the BufferedReader.</span>

<span class="sd">        The return value is True unless EOF was reached.  The decoded string</span>
<span class="sd">        is placed in self._decoded_chars (replacing its previous value).</span>
<span class="sd">        The entire input chunk is sent to the decoder, though some of it</span>
<span class="sd">        may remain buffered in the decoder, yet to be converted.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;no decoder&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_telling</span><span class="p">:</span>
            <span class="c"># To prepare for tell(), we need to snapshot a point in the</span>
            <span class="c"># file where the decoder&#39;s input buffer is empty.</span>

            <span class="n">dec_buffer</span><span class="p">,</span> <span class="n">dec_flags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span><span class="o">.</span><span class="n">getstate</span><span class="p">()</span>
            <span class="c"># Given this, we know there was a valid snapshot point</span>
            <span class="c"># len(dec_buffer) bytes ago with decoder state (b&#39;&#39;, dec_flags).</span>

        <span class="c"># Read a chunk, decode it, and put the result in self._decoded_chars.</span>
        <span class="n">input_chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">read1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_CHUNK_SIZE</span><span class="p">)</span>
        <span class="n">eof</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">input_chunk</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_decoded_chars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">input_chunk</span><span class="p">,</span> <span class="n">eof</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_telling</span><span class="p">:</span>
            <span class="c"># At the snapshot point, len(dec_buffer) bytes before the read,</span>
            <span class="c"># the next input to be decoded is dec_buffer + input_chunk.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot</span> <span class="o">=</span> <span class="p">(</span><span class="n">dec_flags</span><span class="p">,</span> <span class="n">dec_buffer</span> <span class="o">+</span> <span class="n">input_chunk</span><span class="p">)</span>

        <span class="k">return</span> <span class="ow">not</span> <span class="n">eof</span>

    <span class="k">def</span> <span class="nf">_pack_cookie</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">dec_flags</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                           <span class="n">bytes_to_feed</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">need_eof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">chars_to_skip</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="c"># The meaning of a tell() cookie is: seek to position, set the</span>
        <span class="c"># decoder flags to dec_flags, read bytes_to_feed bytes, feed them</span>
        <span class="c"># into the decoder with need_eof as the EOF flag, then skip</span>
        <span class="c"># chars_to_skip characters of the decoded result.  For most simple</span>
        <span class="c"># decoders, tell() will often just give a byte offset in the file.</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">position</span> <span class="o">|</span> <span class="p">(</span><span class="n">dec_flags</span><span class="o">&lt;&lt;</span><span class="mi">64</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">bytes_to_feed</span><span class="o">&lt;&lt;</span><span class="mi">128</span><span class="p">)</span> <span class="o">|</span>
               <span class="p">(</span><span class="n">chars_to_skip</span><span class="o">&lt;&lt;</span><span class="mi">192</span><span class="p">)</span> <span class="o">|</span> <span class="nb">bool</span><span class="p">(</span><span class="n">need_eof</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">256</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_unpack_cookie</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bigint</span><span class="p">):</span>
        <span class="n">rest</span><span class="p">,</span> <span class="n">position</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">bigint</span><span class="p">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">64</span><span class="p">)</span>
        <span class="n">rest</span><span class="p">,</span> <span class="n">dec_flags</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">64</span><span class="p">)</span>
        <span class="n">rest</span><span class="p">,</span> <span class="n">bytes_to_feed</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">64</span><span class="p">)</span>
        <span class="n">need_eof</span><span class="p">,</span> <span class="n">chars_to_skip</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">rest</span><span class="p">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">64</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">position</span><span class="p">,</span> <span class="n">dec_flags</span><span class="p">,</span> <span class="n">bytes_to_feed</span><span class="p">,</span> <span class="n">need_eof</span><span class="p">,</span> <span class="n">chars_to_skip</span>

    <span class="k">def</span> <span class="nf">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seekable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s">&quot;underlying stream is not seekable&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_telling</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s">&quot;telling position disabled by next() call&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="n">decoder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span>
        <span class="k">if</span> <span class="n">decoder</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars</span><span class="p">:</span>
                <span class="c"># This should never happen.</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s">&quot;pending decoded text&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">position</span>

        <span class="c"># Skip backward to the snapshot point (see _read_chunk).</span>
        <span class="n">dec_flags</span><span class="p">,</span> <span class="n">next_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot</span>
        <span class="n">position</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">next_input</span><span class="p">)</span>

        <span class="c"># How many decoded characters have been used up since the snapshot?</span>
        <span class="n">chars_to_skip</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars_used</span>
        <span class="k">if</span> <span class="n">chars_to_skip</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># We haven&#39;t moved from the snapshot point.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pack_cookie</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">dec_flags</span><span class="p">)</span>

        <span class="c"># Starting from the snapshot position, we will walk the decoder</span>
        <span class="c"># forward until it gives us enough decoded characters.</span>
        <span class="n">saved_state</span> <span class="o">=</span> <span class="n">decoder</span><span class="o">.</span><span class="n">getstate</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c"># Note our initial start point.</span>
            <span class="n">decoder</span><span class="o">.</span><span class="n">setstate</span><span class="p">((</span><span class="n">b</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">dec_flags</span><span class="p">))</span>
            <span class="n">start_pos</span> <span class="o">=</span> <span class="n">position</span>
            <span class="n">start_flags</span><span class="p">,</span> <span class="n">bytes_fed</span><span class="p">,</span> <span class="n">chars_decoded</span> <span class="o">=</span> <span class="n">dec_flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
            <span class="n">need_eof</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c"># Feed the decoder one byte at a time.  As we go, note the</span>
            <span class="c"># nearest &quot;safe start point&quot; before the current location</span>
            <span class="c"># (a point where the decoder has nothing buffered, so seek()</span>
            <span class="c"># can safely start from there and advance to this location).</span>
            <span class="k">for</span> <span class="n">next_byte</span> <span class="ow">in</span> <span class="n">next_input</span><span class="p">:</span>
                <span class="n">bytes_fed</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">chars_decoded</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">decoder</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">next_byte</span><span class="p">))</span>
                <span class="n">dec_buffer</span><span class="p">,</span> <span class="n">dec_flags</span> <span class="o">=</span> <span class="n">decoder</span><span class="o">.</span><span class="n">getstate</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">dec_buffer</span> <span class="ow">and</span> <span class="n">chars_decoded</span> <span class="o">&lt;=</span> <span class="n">chars_to_skip</span><span class="p">:</span>
                    <span class="c"># Decoder buffer is empty, so this is a safe start point.</span>
                    <span class="n">start_pos</span> <span class="o">+=</span> <span class="n">bytes_fed</span>
                    <span class="n">chars_to_skip</span> <span class="o">-=</span> <span class="n">chars_decoded</span>
                    <span class="n">start_flags</span><span class="p">,</span> <span class="n">bytes_fed</span><span class="p">,</span> <span class="n">chars_decoded</span> <span class="o">=</span> <span class="n">dec_flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">chars_decoded</span> <span class="o">&gt;=</span> <span class="n">chars_to_skip</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># We didn&#39;t get enough decoded data; signal EOF to get more.</span>
                <span class="n">chars_decoded</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">decoder</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">b</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">final</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
                <span class="n">need_eof</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">chars_decoded</span> <span class="o">&lt;</span> <span class="n">chars_to_skip</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s">&quot;can&#39;t reconstruct logical file position&quot;</span><span class="p">)</span>

            <span class="c"># The returned cookie corresponds to the last safe start point.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pack_cookie</span><span class="p">(</span>
                <span class="n">start_pos</span><span class="p">,</span> <span class="n">start_flags</span><span class="p">,</span> <span class="n">bytes_fed</span><span class="p">,</span> <span class="n">need_eof</span><span class="p">,</span> <span class="n">chars_to_skip</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">decoder</span><span class="o">.</span><span class="n">setstate</span><span class="p">(</span><span class="n">saved_state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cookie</span><span class="p">,</span> <span class="n">whence</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;tell on closed file&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seekable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s">&quot;underlying stream is not seekable&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">whence</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c"># seek relative to current position</span>
            <span class="k">if</span> <span class="n">cookie</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s">&quot;can&#39;t do nonzero cur-relative seeks&quot;</span><span class="p">)</span>
            <span class="c"># Seeking to the current position should attempt to</span>
            <span class="c"># sync the underlying buffer with the current position.</span>
            <span class="n">whence</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">cookie</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">whence</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c"># seek relative to end of file</span>
            <span class="k">if</span> <span class="n">cookie</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s">&quot;can&#39;t do nonzero end-relative seeks&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_decoded_chars</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">position</span>
        <span class="k">if</span> <span class="n">whence</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;invalid whence (</span><span class="si">%r</span><span class="s">, should be 0, 1 or 2)&quot;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">whence</span><span class="p">,))</span>
        <span class="k">if</span> <span class="n">cookie</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;negative seek position </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cookie</span><span class="p">,))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="c"># The strategy of seek() is to go back to the safe start point</span>
        <span class="c"># and replay the effect of read(chars_to_skip) from there.</span>
        <span class="n">start_pos</span><span class="p">,</span> <span class="n">dec_flags</span><span class="p">,</span> <span class="n">bytes_to_feed</span><span class="p">,</span> <span class="n">need_eof</span><span class="p">,</span> <span class="n">chars_to_skip</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_unpack_cookie</span><span class="p">(</span><span class="n">cookie</span><span class="p">)</span>

        <span class="c"># Seek back to the safe start point.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">start_pos</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_decoded_chars</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># Restore the decoder to its state from the safe start point.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span> <span class="ow">or</span> <span class="n">dec_flags</span> <span class="ow">or</span> <span class="n">chars_to_skip</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_decoder</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span><span class="o">.</span><span class="n">setstate</span><span class="p">((</span><span class="n">b</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">dec_flags</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot</span> <span class="o">=</span> <span class="p">(</span><span class="n">dec_flags</span><span class="p">,</span> <span class="n">b</span><span class="s">&#39;&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">chars_to_skip</span><span class="p">:</span>
            <span class="c"># Just like _read_chunk, feed the decoder and save a snapshot.</span>
            <span class="n">input_chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">bytes_to_feed</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_decoded_chars</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">input_chunk</span><span class="p">,</span> <span class="n">need_eof</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot</span> <span class="o">=</span> <span class="p">(</span><span class="n">dec_flags</span><span class="p">,</span> <span class="n">input_chunk</span><span class="p">)</span>

            <span class="c"># Skip chars_to_skip of the decoded characters.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">chars_to_skip</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s">&quot;can&#39;t restore logical file position&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars_used</span> <span class="o">=</span> <span class="n">chars_to_skip</span>

        <span class="k">return</span> <span class="n">cookie</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">decoder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_decoder</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># Read everything.</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_decoded_chars</span><span class="p">()</span> <span class="o">+</span>
                      <span class="n">decoder</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">read</span><span class="p">(),</span> <span class="n">final</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_decoded_chars</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Keep reading chunks until we have n characters to return.</span>
            <span class="n">eof</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_decoded_chars</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">eof</span><span class="p">:</span>
                <span class="n">eof</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_chunk</span><span class="p">()</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_decoded_chars</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_telling</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_telling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seekable</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
        <span class="k">return</span> <span class="n">line</span>

    <span class="k">def</span> <span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;read from closed file&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">limit</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">long</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;limit must be an integer&quot;</span><span class="p">)</span>

        <span class="c"># Grab all the decoded text (we will rewind any extra bits later).</span>
        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_decoded_chars</span><span class="p">()</span>

        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">decoder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_decoder</span><span class="p">()</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="n">endpos</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_readtranslate</span><span class="p">:</span>
                <span class="c"># Newlines are already translated, only search for \n</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">endpos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_readuniversal</span><span class="p">:</span>
                <span class="c"># Universal newline search. Find any of \r, \r\n, \n</span>
                <span class="c"># The decoder ensures that \r\n are not split in two pieces</span>

                <span class="c"># In C we&#39;d look for these in parallel of course.</span>
                <span class="n">nlpos</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
                <span class="n">crpos</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\r</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">crpos</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nlpos</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="c"># Nothing found</span>
                        <span class="n">start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c"># Found \n</span>
                        <span class="n">endpos</span> <span class="o">=</span> <span class="n">nlpos</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="k">break</span>
                <span class="k">elif</span> <span class="n">nlpos</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="c"># Found lone \r</span>
                    <span class="n">endpos</span> <span class="o">=</span> <span class="n">crpos</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">nlpos</span> <span class="o">&lt;</span> <span class="n">crpos</span><span class="p">:</span>
                    <span class="c"># Found \n</span>
                    <span class="n">endpos</span> <span class="o">=</span> <span class="n">nlpos</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">nlpos</span> <span class="o">==</span> <span class="n">crpos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c"># Found \r\n</span>
                    <span class="n">endpos</span> <span class="o">=</span> <span class="n">crpos</span> <span class="o">+</span> <span class="mi">2</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># Found \r</span>
                    <span class="n">endpos</span> <span class="o">=</span> <span class="n">crpos</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># non-universal</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_readnl</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">endpos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_readnl</span><span class="p">)</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="n">limit</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="p">:</span>
                <span class="n">endpos</span> <span class="o">=</span> <span class="n">limit</span>  <span class="c"># reached length limit</span>
                <span class="k">break</span>

            <span class="c"># No line ending seen yet - get more data</span>
            <span class="n">more_line</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_chunk</span><span class="p">():</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoded_chars</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_decoded_chars</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># end of file</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_decoded_chars</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_snapshot</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">return</span> <span class="n">line</span>

        <span class="k">if</span> <span class="n">limit</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">endpos</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">:</span>
            <span class="n">endpos</span> <span class="o">=</span> <span class="n">limit</span>  <span class="c"># don&#39;t exceed limit</span>

        <span class="c"># Rewind _decoded_chars to just after the line ending we found.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rewind_decoded_chars</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">-</span> <span class="n">endpos</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">line</span><span class="p">[:</span><span class="n">endpos</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">newlines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span><span class="o">.</span><span class="n">newlines</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decoder</span> <span class="k">else</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="StringIO"><a class="viewcode-back" href="../api.html#io.StringIO">[docs]</a><span class="k">class</span> <span class="nc">StringIO</span><span class="p">(</span><span class="n">TextIOWrapper</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;An in-memory stream for text. The initial_value argument sets the</span>
<span class="sd">    value of object. The other arguments are like those of TextIOWrapper&#39;s</span>
<span class="sd">    constructor.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_value</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s">&quot;utf-8&quot;</span><span class="p">,</span>
                 <span class="n">errors</span><span class="o">=</span><span class="s">&quot;strict&quot;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">StringIO</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">BytesIO</span><span class="p">(),</span>
                                       <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
                                       <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span>
                                       <span class="n">newline</span><span class="o">=</span><span class="n">newline</span><span class="p">)</span>
        <span class="c"># Issue #5645: make universal newlines semantics the same as in the</span>
        <span class="c"># C version, even under Windows.</span>
        <span class="k">if</span> <span class="n">newline</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_writetranslate</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">initial_value</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">initial_value</span><span class="p">,</span> <span class="nb">unicode</span><span class="p">):</span>
                <span class="n">initial_value</span> <span class="o">=</span> <span class="nb">unicode</span><span class="p">(</span><span class="n">initial_value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">initial_value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getvalue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_encoding</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_errors</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">ExperimentDB v0.2.dev documentation</a> &raquo;</li>
          <li><a href="index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010-2011, Dave Bridges.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.5.
    </div>
  </body>
</html>